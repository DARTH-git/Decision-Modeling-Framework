---
title: "Sick-Sicker case study - as part of the framework paper"
author: "DARTH workgroup"
date: '`r Sys.Date()`'
output: 
  word_document:
    toc: yes     # table of content
    toc_depth: 1 # depth of the table of content
  pdf_document: default
    #fig_caption: yes
  html_document: default
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Set working directory via relative path to root from Rmd
# to avoid issue with the Markdown 
# http://pbahr.github.io/tips/2016/04/16/fix_rmarkdown_working_directory_issue
knitr::opts_knit$set(root.dir = '~/Dropbox (Persoonlijk)/03_Onderzoek/DARTH framework/Decision-Modeling-Framework')
```


```{r load_packages, include = FALSE, warning = FALSE}
library(knitr)
# https://haozhu233.github.io/kableExtra/awesome_table_in_html.html
library(kableExtra) 
library(dplyr)
library(reshape2)
library(ggplot2)
library(scales) # for dollar signs and commas
library(tensorA) # to use tensor algebra
```

```{r read chunks, include = FALSE}
source("R/01_model-inputs.R")
source("R/02_simulation-model.R")
#source("R/03_calibration.R")
source("R/04_validation.R")
#source("R/05a_deterministic-analysis.R")
#source("R/05b_uncertainty-analysis.R")
```

## How to read this document
This document is meant guide you through the `R` code we use to showcase our framework via a fully functional decision model. In this case-study we perform a cost-effectiveness analysis (CEA) using a previously published 4-state model called the Sick-Sicker model.[@Enns2015] This document is supportive material to the *A need for change! A coding framework for improving transparency in decision modeling* paper from the DARTH workgroup. Therefore, rou are recommended to read that paper first, before continue reading this file. 

As described in the paper, this document is guiding you through all the files we need to perforem the CEA analysis of the Sick-Sicker model. The framework can be downloaded from Github (https://github.com/DARTH-git/Decision-Modeling-Framework). We recommend downloading this complete framework as a .zip file containing all folders. Unzip the folder and save it on your computer. In our framework, you find multiple folders as described in Table 1. When you like to follow along, please make sure you installed all packages we used in our code. [REFER TO FILE WITH ALL PACKAGES]. To prepare for running the code you should open the XX file, in the XX folder containing the code to install all `R` packages needed. 

We start this document by repeating the Sick-sicker case example description, followed by guiding you through the different components as described in the paper. As explained in the paper, our file organization consist of several folder. This markdown manuscript can be found in the *manuscript* folder. Our figures can be found in the *figs* folder, data is the *data* folder and when we talk about functions, printed in *italic* style, you can find them in the *functions* folder. All other `R` files can be found in the `R`-script folder. In this document we refer a lot to the `R` code but we don't allways show all of this. We therefore, it is very useful to have the complete framework downloaded.  

## The Sick-Sicker model 
In the Sick-Sicker model, a hypothetical disease affects individuals with an average age of `r n.age.init` years and results in increased mortality, increased treatment costs and reduced quality of life. We simulate a hypothetical cohort of `r n.age.init`-year-old individuals over a lifetime (or reaching age `r n.age.init + n.t` years old) using `r n.t` annual cycles, represented with `n.t`. The cohort start in the "Healthy" health state (denoted "H"). Healthy individuals are at risk of developing the illness, at which point they would transition to the first stage of the disease (the "Sick" health state, denoted "S1"). Sick individuals are at risk of further progressing to a more severe stage (the "Sicker" health state, denoted "S2"), which is constant in this case example. There is a chance that individuals in the Sick state eventually recover and return back to the Healthy healthy state. However, once an individual reaches the Sicker health state, they cannot recover; that is, the probability of transitioning to the Sick or Healthy health states from the Sicker health state is zero. Individuals in the Healthy state face background mortality that is age-specific (i.e., time-dependent). Sick and Sicker individuals face an increased mortality in the form of a hazard rate ratio (HR) of 3 and 10 times, respectively, on the background mortality rate. Sick and Sicker individuals also experience increased health care costs and reduced QoL compared to healthy individuals. Once simulated individuals die, they transition to the "Dead" health state (denoted "D"), where they remain. Figure \ref{fig:STM Sick-Sicker} shows the state-transition diagram of the Sick-Sicker model. The evolution of the cohort is simulated in one-year discrete-time cycles. Both costs and QALYs are discounted at an annual rate of `r d.e` %. 

![Sick-Sicker \label{fig:STM Sick-Sicker}](../figs/Sick-Sicker figure.png)

Two alternative strategies exist for this hypothetical disease: a no-treatment and a treatment strategy. Under the treatment strategy, Sick and Sicker individuals receive treatment and continue doing so until they recover or die. The cost of the treatment is additional to the cost of being Sick or Sicker for one year. The treatment improves QoL for those individuals who are Sick but has no effect on the QoL of those who are sicker. 

We assume that most of the parameters of the Sick-Sicker model and their uncertainty have been previously estimated and are known to the analyst. However, while we can identify those who are afflicted with the illness through obvious symptoms, we can’t easily distinguish those in the S1 state from the those in the S2 state. Thus, we can’t directly estimate state-specific mortality hazard ratios, nor do we know the transition probability of progressing from S1 to S2. Therefore, we calibrated the model to different epidemiological data. We internally validated the calibrated model by comparing the predicted outputs from the model evaluated at the calibrated parameters against the calibration targets. 

As part of the cost-effectiveness analysis (CEA), we conducted different deterministic sensitivity analysis (SA), including one-way and two-way SA, and tornado plots. To quantify the effect of parameter uncertainty on decision uncertainty, we conducted a probabilistic sensitivity analysis (PSA) and reported our uncertainty analysis results with a cost-effectiveness acceptability curve (CEAC), cost-effectiveness acceptability frontier (CEAF) and expected loss curves (ELC). We also conducted a value of information (VOI) analysis to determine whether potential future research is needed to reduce parameter uncertainty.
All steps of the cost-effectiveness analysis will be described using the different components of the framework. 


###01 Define model inputs
As described in the paper, in this component we declare all model input variables and set their values. The `R` script running all components of this section is the *01_model-inputs.R* file in the `R` script folder. 

The input to inform the values is categorized in three categories: external, estimated, and calibrated. The majority of the Sick-Sicker model parameters are informed by external data, while only three parameter values need to be estimated using model calibration. 

In this component we start with the general setup of the model, specifying among others the time horizon, prevalence of the different health states at the start of the model and discount rates. The next step is to declare and inform the external parameter. The model parameter values and `R` variable names are presented in Table \ref{tab:parameters}. 

Table: \label{tab:parameters} Description of parameters with their `R` name and value.

|           **Parameter**            |  **R name** |   **Value**   |
|:-----------------------------------|:-----------:|:-------------:|
| Time horizon ($n_t$)               | `n.t`       | `r n.t` years |
| Names of health states ($n$)       | `v.n`       | H, S1, S2, D  |
| Annual discount rate (costs/QALYs) | `d.c`/`d.e` |  3%           |
| Annual transition probabilities    |             |               |
| - Disease onset (H to S1)          | `p.HS1`     |  `r df.params.init$p.HS1`         |
| - Recovery (S1 to H)               | `p.S1H`     |  `r df.params.init$p.S1H`          |
| - Disease progression (S1 to S2)  in the time-homogenous model   | `p.S1S2`    |  `r df.params.init$p.S1S2`        |
| Annual mortality                   |             |               |
| - All-cause mortality (H to D)     | `p.HD`      |  age-specific |
| - Hazard ratio of death in S1 vs H | `hr.S1`     |  `r df.params.init$hr.S1`            |
| - Hazard ratio of death in S2 vs H | `hr.S2`     |  `r df.params.init$hr.S1`           |
| Annual costs                       |             |               |
| - Healthy individuals              | `c.H`       |  $2,000       |
| - Sick individuals in S1           | `c.S1`      |  $4,000       |
| - Sick individuals in S2           | `c.S2`      |  $15,000      |
| - Dead individuals                 | `c.D`       |  $0           |
| - Additional costs of sick individuals treated in S1 or S2           | `c.Trt`     |  $12,000      |
| Utility weights                    |             |               |
| - Healthy individuals              | `u.H`       |  1.00         |
| - Sick individuals in S1           | `u.S1`      |  0.75         |
| - Sick individuals in S2           | `u.S2`      |  0.50         |
| - Dead individuals                 | `u.D`       |  0.00         |
| Intervention effect                |             |               |
| - Utility for treated individuals in S1 | `u.Trt` |  0.95        |

The all-cause mortality of healthy individuals is age specific. We therefore load the *01_all-cause-mortality-USA-2015.csv* file, including the age-, sex- and race- (ASR) specific mortality rates for the US population in 2015 derived from the Human Mortality database.

The other external parameter values are all stored the 01_init-params.csv file in the data folder. Based on this file a base-case parameters set, an `R` data frame, of this information is generated by the `f.generate_init_params()` function. Using a function to create a basecase parameters dataframe might see complex, but it is important for the sensitivity analysis we will do in component 5 of the framework. 

```{r}
print.function(f.define_init_params) # print the code of the function
```

In this code you can see that the functions start calling the .csv file and stores the values of the parameters. All of this is combined in a dataframe. The Sick-Sicker model does not have estimated parameters, but there are three parameters that need to be estimated via model calibration. In this stage of the framework, we simply set these parameters to valid “dummy” values that are compatible with the next phase of the analysis, model implementation, but are ultimately just placeholder values until we conduct the calibration phase. This means that these values will be replaced by the best-fitted calibrated values after we performed the calibration. 


###02 Model implementation
In this component we build the backbone of the decision analysis: the implementation of the model. In this section of the framework, all combined in the *02_simulation-model.R* `R` script, a function is used that maps model inputs to outputs, for the Markov model we are using to capture the dynamic process of the Sick-Sicker example. The *02_simulation-model.R* file itself is not very large. It is loading some packages, sources the input from component 01, sources the function that is creating the model, after which the functions is ran and the results are stored. The output of the model is the traditional cohort trace, describing how the cohort is distributed among the different health states over time. This trace will be used in many of the other component sections. 

The key component of this file, is the *02_simulation-model_functions.R* file. As described in the paper, constructing a model as a function at this stage facilitates subsequent stages of the model development and analysis, as these processes will all call the same model function, but pass different parameter values and/or calculate different final outcomes based on the model outputs. In the next part of this section we will describe the code of the function.

```{r}
print.function(f.decision_model) # print the code of the function
```

The `f.decision_model()` function is informed by just one argument, called `v.params`. This argument informs the model about the model parameters. The parameter values for our Sick-Sicker model are stored in the dataframe `df.params` and is passed into the function as an argument.

```{r, eval = FALSE, echo = TRUE}
l.out.stm <- f.decision_model(v.params = df.params.init) # run the function
```

You probably noticed that the prefix of the argument is telling us it has to be a vector, while we pass a dataframe into the function. This is totally fine. The function is able to deal with both vectors, usefull for small models, as well as dataframes, when you have more parameter info. 

The functions starts with calculating the age-specific transition probabilities based on the rates in the data frame. This means that the parameters will become vectors of length `n.t`, describing the probability do die for all ages. 

The next part of the function, creates the age-specific transition probability matrices in an array. The transition probability matrices a core component of a state-transition cohort model. This matrix contains the probabilities of transitioning from the current health state, indicated by the rows, towards the new health states, specified in the columns. More information about creating these matrices is described in a paper about State-transition models using R [@Alarid-Escudero2018]. Since we have age specific transition probabilities, the transition probability matrix is different each cycle. Since these probabilities are only depending on the age of the cohort, and not on other events, we can generate all matrices at the start of the model. This results `n.t` matrices that we will store in an array, called `a.P`, of dimensions `n.s` x `n.s` x `n.t`. After initiation this array the array is filled based on the parameter values stored in the dataframe. When running the model, we can index the correct transition probability matrix corresponding with the current age of the cohort. The make sure we are using correct values, the functions include some code to check if both the transition probabilities them self, as well as the transition probability matrices are valid. The first three time-points of the probability array, as well as for the last cycle, are shown below.

```{r, echo = FALSE, eval = TRUE}
l.out.stm$a.P[, , 1:3] # show the first three time-points of a.P
l.out.stm$a.P[, , n.t] # transition probability matrix for the last cycle
```

Comparing these probability matrices, shows you the increased probabilities of transitioning to death form all health states towards the end. 

After the array is filled, the cohort trace matrix, `m.M`, of dimensions `n.t` x `n.s` is initiated. This matrix will store the state occupation at each point in time.  The first row of the matrix is informed by the initial state vector `v.s.init`. For the remaining points in time, we iteratively multiply the cohort trace with the age specific transition probability matrix indexed from array `a.P`. The model results are stored in a list, called `l.out.stm`. This list contains the array of the transition probability matrix for all cycles `t` and the cohort trace `m.M`. 

```{r, eval = TRUE, echo = TRUE}
head(l.out.stm$m.M)    # show the top part of the cohort trace
tail(l.out.stm$m.M)    # show the bottom part of the cohort trace
```

Via the code below, we can graphically show the model dynamics by plotting the cohort trace. This Figure shows the distribution of the cohort among the different health states at each time point. 

```{r Sick-Sicker-Trace, echo = FALSE, fig.cap = 'Cohort trace of the Sick-Sicker cohort model', message = FALSE, warning = FALSE, fig.pos = "H"} 
ggplot(melt(l.out.stm$m.M), aes(x = Var1, y = value, color = Var2, linetype = Var2)) +
  geom_line(size = 1.3) +
  scale_color_discrete(l = 50, name = "Health state") +
  scale_linetype_discrete(name = "Health state") +
  xlab("Cycle") +
  ylab("Proportion of the cohort") +
  theme_bw(base_size = 16) +
  theme()
# matplot(m.M, pch = v.n)
```

###03 Model calibration 
```{r, eval = TRUE, echo = FALSE}
source("functions/03_calibration_functions.R")
```
In this component, unknown or highly uncertain model parameters are estimated by calibrating model outputs to match specified calibration targets. This proces is executed by the *03_calibration.R* file. The target data is stored in the *03_calibration-targets.RData* file. The *03_calibration.R* file include much more code compared to the `R` scripts of the previous components. Like in compontent 02, we start with loading inputs and functions. In addition, we load the calibration targets data into the `R` environment. In the next section, **03.2 Visualize targets**, we create a graph for each of our targets, survival, prevalence and the proportion who are Sicker, among all those afflicted (Sick+Sicker). 

In section **03.3 Run calibration algorithms**  we set the parameters we like to calibrate to fixed values and tast if our functions performing the calibrations, called `f.calibration_out` works. 

```{r}
print.function(f.calibration_out) # print the funtions
```

This function is informed by one argument, `v.params.calib`. This vector contains the values of the three parameters of interest. The placeholder values are replaced by these values and with these values the model is evaluated. This is done by running the `f.decision_model` function, described in component 02. This results in a new list with output of the model. With this new output, the epidemiological output, overal survial, disease prevalence and the proportion of sick in the sick and sicker state are calculated. The estimated values for these epidemiological outcomes at different timepoints are combined in a list, called `l.out`. This is the output from the `f.calibration_out` function. 

Now we know our code works, we specify our calibration paratmers in section **03.3.1**. This includes setting the see, specifying the number of random samples, the name of the input paramters and most important, the range on input search spaces and the name of the calibration targets, `Surv`, `Prev`, `PropSick`.

In the next section, **03.3.2**, to calibrate the Sick-Sicker model, we use a Bayesian approach using the incremental mixture importance sampling (IMIS) algorithm [Teele2006], which has been used to calibrate health policy models [Raftery2010, @Menzies2017, Rutter2018]. Bayesian methods allow us to quantify the uncertainty in the calibrated parameters even in the presence of non-identifiability [@Alarid-Escudero2018b]. We assumed a normal likelihood and uniform priors. For a more detailed description of IMIS for Bayesian calibration, different likelihood functions and prior distributions, we refer the reader to the tutorial for Bayesian calibration by Menzies et al. [@Menzies2017]. We use the `IMIS` function from the likenames package that 
is calling the functions `f.log_lik`, `likelihood`, `sample.prior`, `f.log_prior` and `prior`, that are specified in the `03_calibration_functions.R` file, to draw samples from the the posterior distribution of multivariate variable. We respectively specify the incremental sample size at each iteration of IMIS, the desired posterior sample size at the resample stage, the maximum number of iterations in IMIS and the number of optimizers which could be 0. The function returns a list, which we called `l.fit.imis`, with the posterior resamples, the diagnostic statistics at each IMIS iteration and the centers of Gaussian components [@IMIS]. We store the posterior resamples in the matrix `m.calib.post`. 

Now we start exploring this posterior distribution in section **03.4**. From this data, we compute the posterior mean, median and 95% credible interval, mode and maximum-a-posteriori (MAP). All for these summary statistics are combined in a dataframe called, `df.posterior.summ`. 

Interpreting these statistics is quite hard and works much better via a graphs. Section **03.4.2** generates a visualization of the posterior distribution. These figures are save in the *figures* folder. 

![Posterior distribution joint \label{fig:Posterior-distribution-joint}](../figs/03_posterior-distribution-joint.png)

![Posterior distribution marginal \label{fig:03_posterior-distribution-marginal}](../figs/03_posterior-distribution-marginal.png)
[HOW DO WE INTERPRET THESE FIGURES?]

Finally, the posterior and MAP from the IMIS calibration are stored in the file *03_imis-output.RData*. Storing this data as a datafile gives us the possibility to inport the data without re-running the calibration code. 

For illustration purposes, we also provide code to calibrated the Sick-Sicker model with the Nelder-Mead algorithm [@Nelder1965], which was initialized at 100 different starting points sampled from the prior distributions of the calibrated parameters. This calibration exercise can be found in the file `app2_calibration-nelder-mead.R`, but we will not go into details for this file. 

###04 Validation
In this section, we like to check the internal validity of our Sick-Sicker model before we continue with the analysis. Checking the internal validity means that we need to make sure that the output corresponds with our input. For example, we like to check that Sicker individuals can not recover and that most of our cohort died by the end of the time horizon. We also plot our model-predicted outputs against the calibration targets. Therefore, the *04_validation.R* file stats with sourcing all previously described functions and generated calibration data. 

We compute the model-predicted outputs for each sample of posterior distribution as well as for the MAP estimate. Section *04.5* is computing these model-predicted outputs for each sample using the function `f.data_summary`. 
```{r}
print.function(f.data_summary)
```
This function is informed by three arguments, `data`, `varname` and `groupnames`. 

The computation of the model-predicted outputs using the MAP estimates is done by inserting the `v.calib.post.map` data into the previously described `f.calibration_out` function. This function creates a list including the estimated values for survival, prevalence and the proportion of sicker individuals at the time points 10, 20 and 30. 

In sections **04.6 Internal validation: Model-predicted outputs vs. targets** we check the internal validation of our model-predicted outputs versus our targets using plots. The generated plots are saved as .png files, which in turn can be used without the need of re-running the code. 

![Survival data: Posterior vs targets  \label{fig:04_surv}](../figs/04_posterior-vs-targets-survival.png)

![Prevalence data: Posterior vs targets  \label{fig:04_p}](../figs/04_posterior-vs-targets-prevalence.png)

![Proportion sicker data: Posterior vs targets  \label{fig:04_proportion}](../figs/04_posterior-vs-targets-proportion-sicker.png)
**[Do we need an interpretation of the graphs?]**

### 05: Analysis
The analysis component is where the model developed in components 1-4 is applied to answer the question(s) of interest given current information. Our framework separates the analysis in three subcomponents, subcomponents **5a** being the deterministic analysis, **5b** the uncertainty analysis and **5c** the value of information analysis. For the Sick-Sicker example, all three subcomponents will be used to answer the CE research question and to quantify the uncertainty of our decision. For procedures in the cost-effectiveness analyses, we rely on the R package dampack, which is available here: 
<https://github.com/DARTH-git/dampack>. Instructions for installing dampack are described in Appendix A. provided in the framework *app0_packages-setup.R script*.

####05a Deterministic analysis
In this subcomponent we start with performing the basic CEA, followed by evaluating some of the parameter uncertainy using deterministic sensitivity analysis. The functions file of this subcomponent, `05a_deterministic-analysis_function.R` file contains the functions `f.generate_basecase_params()` and `f.calculate_ce_out`. These `f.generate_basecase_params` function is used to generate a base-case set of paramters needed for the CEA analysis. This included using the function `f.define_init_params` to generate the initial parameter values, as described before, but now the placeholder values are replaced by the calibrated values. 

```{r, eval = FALSE, echo = TRUE}
print(f.generate_basecase_params) # print the function 
```

The results for the `f.generate_basecase_params` function are stored in the variable` v.params.basecase`, containing all the basecase values of the parameters. These values are used as input for the `f.calculate_ce_out` function. The users can also specify the willingness-to-pay (WTP) value using the `n.wtp` argument of the function. This WTP value is used to compute a net monetary benefit (NMB) value. If the users does not specify the WTP, a default value of 100000 will be used by the function. 
```{r, eval = FALSE, echo = TRUE}
print(f.calculate_ce_out) # print the function 
```

The first part of the function runs the decision model using the previously described function `f.decision_model`. Since we set the argument `v.params` equal to `v.params.basecase`, we are now using the basecase parameters rather than the initial values. Running this code gives us a list of output for both the treatment, `l.model.out.trt`, and no treatement, `l.model.out.no_trt` strategy of the Sick-Sicker model. In the second part of the function we create multiple vectors for both the cost and effects of both strategies. These vectors in turn are mulitplied using matrix multiplication, indicated by `%*%` in R, with the Markov trace. This results in vectors of total costs (`v.tc`) and total effects (`v.tu`) per cycle. By multiplying these vectors with the vectors with the discount weights for costs (`v.dwc`) and effects (`v.dwe`) we get the total discounted mean costs (`tc.d_no_trt` and `tc.d_trt`) and QALYs (`tu.d_no_trt` and `tu.d_trt`) for both strategies. These values are used in the calculation the NMB. The total costa, total effectiveness and the NMB are combined in a matrix, called `m.ce`. This matrix is the result of the function. This compact matrix with the CE results can be used as an argumnet in the `calculate_icers` function from the DAMPACK package. 


We now have the results of our CEA and we would like to evaluate the uncertainity around this decision using one-way sensitivity analysis (OWSA). 
XXXXX


####05b Uncertainty analysis 
In this subsection, we evaluate decision uncertainy by evaluating the uncertainty of our parameter values using probabilistic sensitiviy analysis (PSA). Until now we used the parameter values as described in Table {tab:parameters}. However, the truth is that we are uncertain about the described values. Most of these input parameters are defined by a distribtion as described in Table \ref{tab:parameters PSA}. 

Table: \label{tab:parameters PSA} Description of parameters with their R name and value.

|           **Parameter**         |  **R name** |   **Distribtion**   |
  |:--------------------------------|:-----------:|:-------------:|
  | Annual transition probabilities |           |               |
  | - Disease onset (H to S1)       | `p.HS1`     |  `beta(30, 170)`        |
  | - Recovery (S1 to H)            | `p.S1H`     |  `beta(60, 60)`         |
  | Annual costs                    |             |               |
  | - Healthy individuals           | `c.H`       |  `gamma(shape = 100, scale = 20)`        |
  | - Sick individuals in S1        | `c.S1`      |  `gamma(shape = 177.8, scale = 22.5)`       |
  | - Sick individuals in S2        | `c.S2`      |  `gamma(shape = 225, scale = 66.7)`     |
  | - Additional costs of sick individuals treated in S1 or S2           | `c.Trt`     |  `gamma(shape = 73.5, scale = 163.3)`      |
  | Utility weights                 |             |               |
  | - Healthy individuals           | `u.H`       |`truncnorm(mean = 1, sd = 0.01, b = 1)`         |
  | - Sick individuals in S1        | `u.S1`      |`truncnorm(mean = 0.75, sd = 0.02, b = 1)`         |
  | - Sick individuals in S2        | `u.S2`      |`truncnorm(mean = 0.50, sd = 0.03, b = 1)`         |
  | Intervention effect             |             |               |
  | - Utility for treated individuals in S1 | `u.Trt` |`truncnorm(mean = 0.95, sd = 0.02, b = 1)`        |

In a PSA we sample the input parameter values from these distributions and we than run the model for each sample. This means that we need to make multiple PSA data sets to run the model with. In the file *05b_uncertainty-analysis_functions.R* we created a single function, called `f.generate_psa_params`, that is able top generate a PSA dataset of CEA input parameters for each number of simulations we like to have in our PSA. We specify the number of PSA simulation via the `n.sim` argument. The function is also using a seed to allow reproducing the results of this stocastic proces. 

```{r, eval = FALSE, echo = TRUE}
print.function(f.generate_psa_params) # print the function 
```

The function returns a dataframe of PSA output, that can then be used to run the model for each sample. 












####05c Value of information

### References 









